这是一个非常棒的想法。使用 Next.js 开发一个展示 AI 生成代码（HTML/React）的静态网站，不仅性能好，而且 SEO 友好。

核心难点在于：**如何安全、优雅地渲染这些动态生成的代码片段，同时兼顾构建时的静态生成。**

以下是一个完整的架构设计和实现指南：

### 1. 项目架构设计

我们将采用 **“文件系统即数据库” (File System as Database)** 的模式。

* **数据源**：所有的 AI 生成代码以文件形式存储在项目中（例如 `_demos` 文件夹）。
* **构建方式**：Next.js 在构建时读取这些文件，生成静态页面。
* **渲染策略**：
  * **HTML/CSS/JS 单文件**：使用 `<iframe>` 进行沙箱渲染，确保样式隔离且安全。
  * **React 组件**：推荐使用 `@codesandbox/sandpack-react`，它可以在浏览器端实时编译和运行 React 代码字符串，非常适合展示 AI 生成的组件。

### 2. 目录结构规划

```text
my-ai-gallery/
├── app/
│   ├── page.tsx              # 首页：展示所有 Demo 的网格列表
│   ├── demo/
│   │   └── [slug]/
│   │       └── page.tsx      # 详情页：左边代码，右边预览
│   └── layout.tsx
├── components/
│   ├── DemoCard.tsx          # 首页卡片组件
│   ├── HtmlPreview.tsx       # HTML 预览组件 (Iframe)
│   └── ReactPreview.tsx      # React 预览组件 (Sandpack)
├── lib/
│   └── demos.ts              # 读取文件系统的工具函数
├── _demos/                   # 存放 AI 生成的代码
│   ├── 01-glassmorphism-card/
│   │   ├── index.html        # HTML 代码
│   │   └── meta.json         # 元数据 (标题, 提示词, 类型)
│   └── 02-react-todo-list/
│       ├── App.tsx           # React 代码
│       └── meta.json
└── public/
```

### 3. 核心功能实现

#### 第一步：准备数据读取工具 (`lib/demos.ts`)

我们需要在构建时读取 `_demos` 文件夹下的内容。

```typescript
import fs from 'fs';
import path from 'path';

const demoDir = path.join(process.cwd(), '_demos');

export type DemoType = 'html' | 'react';

export interface Demo {
  slug: string;
  title: string;
  description?: string;
  type: DemoType;
  code: string;
}

export function getAllDemos(): Demo[] {
  const folders = fs.readdirSync(demoDir);
  
  return folders.map((folder) => {
    const metaPath = path.join(demoDir, folder, 'meta.json');
    const meta = JSON.parse(fs.readFileSync(metaPath, 'utf-8'));
    
    let codeFilename = meta.type === 'react' ? 'App.tsx' : 'index.html';
    const codePath = path.join(demoDir, folder, codeFilename);
    const code = fs.readFileSync(codePath, 'utf-8');

    return {
      slug: folder,
      ...meta,
      code,
    };
  });
}

export function getDemoBySlug(slug: string): Demo | undefined {
  const demos = getAllDemos();
  return demos.find((d) => d.slug === slug);
}
```

#### 第二步：HTML 预览组件 (`components/HtmlPreview.tsx`)

对于 HTML，最稳妥的方法是使用 iframe 的 `srcDoc` 属性。

```tsx
interface Props {
  code: string;
}

export default function HtmlPreview({ code }: Props) {
  return (
    <div className="w-full h-full border rounded-lg overflow-hidden bg-white">
      <iframe
        srcDoc={code}
        title="HTML Preview"
        className="w-full h-full"
        sandbox="allow-scripts" // 允许脚本，但要注意安全
      />
    </div>
  );
}
```

#### 第三步：React 预览组件 (`components/ReactPreview.tsx`)

这里我们引入强大的 **Sandpack**。它是由 CodeSandbox 开发的，可以在浏览器中运行 React。

*安装依赖:* `npm install @codesandbox/sandpack-react`

```tsx
'use client'; // 必须是客户端组件

import { Sandpack } from "@codesandbox/sandpack-react";

interface Props {
  code: string;
}

export default function ReactPreview({ code }: Props) {
  return (
    <div className="h-full w-full">
      <Sandpack
        template="react-ts"
        theme="dark"
        files={{
          "/App.tsx": code,
        }}
        options={{
          showNavigator: false, // 隐藏浏览器地址栏
          showTabs: false,      // 只有一个文件时隐藏 Tab
          editorHeight: "600px", // 自定义高度
          externalResources: ["https://cdn.tailwindcss.com"], // 注入 Tailwind，因为 AI 经常用
        }}
      />
    </div>
  );
}
```

#### 第四步：详情页路由 (`app/demo/[slug]/page.tsx`)

这是将所有内容整合的地方。我们需要使用 `generateStaticParams` 来生成静态路由。

```tsx
import { getAllDemos, getDemoBySlug } from '@/lib/demos';
import HtmlPreview from '@/components/HtmlPreview';
import ReactPreview from '@/components/ReactPreview';
import Link from 'next/link';

// 1. 生成静态路由 (SSG 关键)
export async function generateStaticParams() {
  const demos = getAllDemos();
  return demos.map((demo) => ({
    slug: demo.slug,
  }));
}

export default function DemoPage({ params }: { params: { slug: string } }) {
  const demo = getDemoBySlug(params.slug);

  if (!demo) return <div>Not Found</div>;

  return (
    <div className="min-h-screen p-8 bg-gray-50 text-black">
      <Link href="/" className="text-blue-500 hover:underline mb-4 block">
        &larr; 返回列表
      </Link>
      
      <div className="mb-6">
        <h1 className="text-3xl font-bold">{demo.title}</h1>
        <p className="text-gray-600 mt-2">{demo.description}</p>
        <span className="inline-block bg-gray-200 rounded px-2 py-1 text-xs mt-2 uppercase">
          {demo.type}
        </span>
      </div>

      <div className="h-[600px] shadow-xl rounded-xl overflow-hidden">
        {demo.type === 'html' ? (
           // 对于 HTML，我们通常左边放代码(使用 text-area 或 prismjs)，右边预览
           // 为了简化，这里 HTML Preview 组件可以直接只展示结果，或者做成分栏
           <div className="grid grid-cols-2 h-full">
             <div className="bg-gray-900 text-white p-4 overflow-auto font-mono text-sm">
               <pre>{demo.code}</pre>
             </div>
             <HtmlPreview code={demo.code} />
           </div>
        ) : (
          // Sandpack 自带编辑器和预览
          <ReactPreview code={demo.code} />
        )}
      </div>
    </div>
  );
}
```

#### 第五步：首页列表 (`app/page.tsx`)

```tsx
import { getAllDemos } from '@/lib/demos';
import Link from 'next/link';

export default function Home() {
  const demos = getAllDemos();

  return (
    <main className="min-h-screen p-12 bg-white text-black">
      <h1 className="text-4xl font-bold mb-8">AI Code Gallery</h1>
      
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
        {demos.map((demo) => (
          <Link 
            key={demo.slug} 
            href={`/demo/${demo.slug}`}
            className="block border rounded-lg p-6 hover:shadow-lg transition bg-gray-50"
          >
            <div className="flex justify-between items-start mb-4">
               <h2 className="text-xl font-semibold">{demo.title}</h2>
               <span className={`text-xs font-bold px-2 py-1 rounded text-white ${demo.type === 'react' ? 'bg-blue-500' : 'bg-orange-500'}`}>
                 {demo.type.toUpperCase()}
               </span>
            </div>
            <p className="text-gray-500 line-clamp-2">{demo.description}</p>
          </Link>
        ))}
      </div>
    </main>
  );
}
```

### 4. 进阶功能与优化建议

1. **AI 提示词 (Prompt) 展示**：
    在 `meta.json` 中增加 `prompt` 字段。在详情页展示 "Copy Prompt" 按钮，让用户知道是什么咒语生成了这个效果。

2. **Tailwind 支持**：
    AI 生成的代码（特别是来自 GPT-4 或 Claude）非常喜欢用 Tailwind CSS。
    * **HTML**: 在 HTML 模板头部手动注入 Tailwind CDN 链接。
    * **React**: 在 Sandpack 配置中的 `externalResources` 加入 Tailwind CDN（如上面代码所示）。

3. **复制代码按钮**：
    在预览框旁边增加“复制代码”按钮，方便用户粘贴使用。

4. **部署 (Static Export)**：
    为了部署到 GitHub Pages 或任何静态托管，修改 `next.config.js`:

    ```javascript
    /** @type {import('next').NextConfig} */
    const nextConfig = {
      output: 'export',
      // 如果部署在非根目录（如 github pages 子路径），需要配置 basePath
    };
    module.exports = nextConfig;
    ```

5. **自动化工作流 (Workflow)**：
    你可以写一个简单的 Node.js 脚本，直接调用 OpenAI API，生成代码后自动写入 `_demos` 文件夹。这样你只需要运行 `npm run generate "a login page"`，网站内容就会自动增加。

### 总结

这套方案使用了 Next.js 的 **App Router** 和 **Static Exports** 保证了速度和 SEO。使用 **Iframe** 隔离 HTML，使用 **Sandpack** 动态编译 React。这不仅是一个展示站，更像是一个小型的在线 IDE，用户体验非常好。

设计 `meta.json` 是这个项目的灵魂。它不仅决定了你在页面上展示什么，还决定了用户如何通过筛选（比如“只看 Claude 3.5 写的代码”或“只看 Cursor 生成的”）来浏览你的作品库。

以下是一个全面且可扩展的元数据结构设计方案：

### 1. JSON 结构设计 (`meta.json`)

我们将数据分为三个维度：**基础信息**、**AI 生成上下文**（你的核心需求）、**技术细节**。

```json
{
  "id": "001-glassmorphism-dashboard",
  "title": "玻璃拟态仪表盘",
  "description": "使用 Tailwind CSS 实现的磨砂玻璃质感数据面板，包含图表占位符。",
  "type": "react",
  
  "ai": {
    "model": "claude-3-5-sonnet",
    "agent": "cursor",
    "provider": "anthropic" 
  },

  "prompt": {
    "main": "创建一个现代化的深色模式仪表盘，使用玻璃拟态风格，包含侧边栏和顶部统计卡片。",
    "iteration": "将背景改为渐变色，并增加卡片的圆角。" 
  },

  "tags": ["dashboard", "glassmorphism", "tailwind", "dark-mode"],
  "createdAt": "2023-10-27T10:00:00Z",
  "version": "1.0"
}
```

### 2. 字段详细解析

#### A. 核心字段 (Core)

| 字段名 | 类型 | 说明 | 示例 |
| :--- | :--- | :--- | :--- |
| `title` | string | 项目的简短标题，用于卡片展示 | "React Todo List" |
| `description` | string | 简短描述，用于 SEO 和列表摘要 | "支持拖拽排序的待办事项..." |
| `type` | string | 代码类型，决定使用哪个渲染器 | `"html"` 或 `"react"` |

#### B. AI 上下文 (AI Context) —— *你最关心的部分*

这部分数据可以让你的网站显得很专业，适合做“模型能力对比”。

| 字段名 | 类型 | 说明 | 示例 |
| :--- | :--- | :--- | :--- |
| `ai.model` | string | 底层大模型版本 | `"gpt-4o"`, `"claude-3-5-sonnet"`, `"deepseek-coder-v2"` |
| `ai.agent` | string | 使用的工具/IDE/Agent | `"cursor"`, `"v0"`, `"bolt.new"`, `"chatgpt-web"`, `"windsurf"` |
| `ai.temperature`| number | (可选) 生成时的随机性参数 | `0.7` |

#### C. 提示词 (Prompts)

展示 Prompt 是此类网站的核心价值，让访客学习如何提问。

| 字段名 | 类型 | 说明 |
| :--- | :--- | :--- |
| `prompt.main` | string | 初始的完整 Prompt |
| `prompt.system` | string | (可选) 系统预设 Prompt (System Message) |
| `prompt.iteration`| string | (可选) 如果是多轮对话生成的，记录关键的修改指令 |

#### D. 系统管理 (System)

| 字段名 | 类型 | 说明 |
| :--- | :--- | :--- |
| `tags` | string[] | 用于分类筛选 | `["animation", "landing-page"]` |
| `createdAt` | string | ISO 时间格式，用于按时间排序 | `"2023-11-29"` |

---

### 3. 在 Next.js 中的 TypeScript 定义

修改 `lib/demos.ts` 中的接口定义，使其获得类型提示：

```typescript
// lib/types.ts

export type DemoType = 'html' | 'react';

export type AIModel = 'gpt-4o' | 'gpt-4-turbo' | 'claude-3-5-sonnet' | 'gemini-pro' | 'deepseek-v2';
export type AIAgent = 'cursor' | 'vscode' | 'v0' | 'bolt' | 'windsurf' | 'chatgpt-web';

export interface AIData {
  model: AIModel;
  agent: AIAgent;
  provider?: string; // e.g., 'openai', 'anthropic'
}

export interface PromptData {
  main: string;
  system?: string;
  iteration?: string; // 记录你是如何让 AI 修改代码的
}

export interface DemoMeta {
  slug: string;       // 从文件夹名称获取
  title: string;
  description: string;
  type: DemoType;
  ai: AIData;
  prompt: PromptData;
  tags: string[];
  createdAt: string;
}

// 最终在页面使用的数据结构（包含代码内容）
export interface Demo extends DemoMeta {
  code: string;
}
```

### 4. UI 展示建议

有了这些丰富的 Meta 数据，你可以在页面设计上玩出很多花样：

1. **卡片角标 (Badges)**：
    在首页卡片上，使用不同的颜色代表不同的 **Agent**。
    * Cursor: 蓝色徽章
    * v0: 黑色徽章
    * ChatGPT: 绿色徽章

2. **模型对比过滤器 (Filter)**：
    在首页增加一个下拉菜单：`Filter by Model`。
    * 用户可以选择 "Show only Claude 3.5 Sonnet"，查看 Claude 的编程能力是否优于 GPT-4。

3. **详情页侧边栏 (Details Sidebar)**：
    在详情页代码预览的下方或侧边，专门开辟一个 **"Generation Info"** 区域：

    ```tsx
    // components/PromptDisplay.tsx
    export default function PromptDisplay({ prompt, ai }: { prompt: PromptData, ai: AIData }) {
      return (
        <div className="bg-gray-100 p-4 rounded-lg mt-6">
          <div className="flex gap-2 mb-3">
             <span className="text-xs font-mono bg-blue-100 text-blue-800 px-2 py-1 rounded">
               Generated by {ai.agent}
             </span>
             <span className="text-xs font-mono bg-purple-100 text-purple-800 px-2 py-1 rounded">
               Model: {ai.model}
             </span>
          </div>
          
          <h3 className="font-bold text-sm text-gray-700 mb-1">Prompt:</h3>
          <p className="font-mono text-sm text-gray-600 bg-white p-3 border rounded">
            {prompt.main}
          </p>
          
          {prompt.iteration && (
            <div className="mt-2">
              <h3 className="font-bold text-sm text-gray-700 mb-1">Refinements:</h3>
               <p className="font-mono text-sm text-gray-500 italic">
                 " -> {prompt.iteration}"
               </p>
            </div>
          )}
        </div>
      )
    }
    ```

这样设计，你的网站就不只是一个代码仓库，而变成了一个 **AI 编程能力的评估和展示平台**，价值大大提升。
